> 简单工厂模式
#
    function createPop(type, text){
      var o = new Object();
      o.content = text;
      o.show = function(){
        //showing method
      };
      if(type == 'alert'){

      }
      if(type == 'prompt'){

      }
      if(type == 'confirm'){

      }
      return o;
    }

>工厂方法模式
#
    //Factory Method
    //安全模式创建的工厂类，工厂中以方法主导，
    var Factory = function(type,content){
        if(this instanceof Factory){
            var s = new this[type](content);
            return s;
        }else{
            return new Factory(type,content);
        }
    }

    Factory.prototype = {
        Java : function(content){
            // ......
        },
        JavaScript: function(content){
            // ......
        },
        UI : function(content){
            this.content = content;
            //通过闭包直接执行，将内容按照需求的样式插入到页面中
            (function(content){
                var div = document.createElement('div');
                div.innerHTML = content;
                div.style.border = '1px solid red';
                document.getElementById('container').appendChild(div);
            })(content);
        },
        php: function(content){
            // ......
        }
    };
    
> 抽象工厂模式
#
    //Abstract Factory
    //在继承上的作用，如果定义了一个类，并定义了类所必备的方法，如果子类中没有重写这些方法在调用的时候将会报错。
    //抽象工厂方法
    var VehicleFactory = function(subType, superType){
      //判断抽象工厂中是否有该抽象类
      if(typeof VehicleFactory[superType] === 'function'){
        //缓存类
        function F(){};
        //继承父类属性和方法
        F.prototype = new VehicleFactory[superType]();
        //将子类constructo指向子类
        subType.constructor = subType;
        //将子类原型继承父类
        subType.prototype = new F();
      }else{
        //不存在该抽象类抛出错误
        throw new Error('未创建该抽象类');
      }
    }
    //小汽车抽象类
    VehicleFactory.Car = function(){
      this.type = 'car';
    };
    VehicleFactory.Car.prototype = {
      getPrice: function(){
        return new Error('抽象方法不能被使用');
      },
      getSpeed: function(){
        return new Error('抽象方法不能被使用');
      }
    };
    //bus抽象类
    VehicleFactory.Bus = function(){
      this.type = 'bus'
    };
    VehicleFactory.Bus.prototype = {
      getPrice: function(){
        return new Error('抽象方法不能被使用');
      },
      getPassengerNum: function(){
        return new Error('抽象方法不能被使用');
      }
    };
    var BMW = function(price,speed);
    VehicleFactory(BMW,'Car');
    BMW.prototype.getPrice = function(){
      return this.price;
    }
    
> 建造者模式
* Builder: 将一个复杂对象的构建层与表示层分离，同样的构建过程中采用不同的表示。在意创建的细节
#
    //Builder
    //创建人类
    var Human = function(param){
      //如果存在param和param.skill属性则赋予this.skill不然设置为保密
      this.skill = param && param.skill || '保密';
      this.hobby = param && param.hobby || '保密';
    }
    //人类原型
    Human.prototype = {
      getSkill : function(){
        return this.skill;
      },
      getHobby : function(){
        return this.hobby;
      }
    }
    //实例化姓名类
    var Name = function(name){
      var that = this;
      //constructor
      (function(name,that){
        that.wholename = name;
        if(name.indexOf(' ') > -1){
          this.FirstName = name.slice(0,name.indexOf(' '));
          this.SecondName = name.slice(name.indexOf(' '));
        }
      })(name,that);
    }
    //实例化职位类
    var Work = function(work){
        var that = this;
      //constructor
      (function(work,that){
        switch(work){
          case 'code':
            that.work = 'engineer';
            that.workDescript = 'codeEveryDay';
          case 'UI':
          case 'UE':
            that.work = 'designer';
            that.workDescript = 'designAsArt';
        }
      })(name,that);
    }
    //变更期望职位
    Work.prototype.changeWork = function(work){
      this.work = work;
    }
    //变更职位描述
    Work.prototype.changeDescript = function(sentence){
      this.workDescript = sentence;
    }
    //最终的建造者类
    /*
    应聘者建造者
    参数 name：姓名（全名）
    参数 work：期望职位
    */
    var Person = function(name,work){
      //创建应聘者
      var _person = new Human();
      _person.name = new Name(name);
      _person.work = new Work(work);
      return _person;
    }

> 原型模式
* 将可复用可共享的耗时大的从基类中提出来然后放在其原型中，然后子类通过组合继承或者寄生组合式继承将方法和属性继承下来，并对子类中需要重写的方法进行重写。
